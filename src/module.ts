import { mkdir, readFile, rm, writeFile } from 'node:fs/promises'
import type { NitroRouteRules } from 'nitropack'
import { addComponent, addImports, addServerHandler, addTemplate, createResolver, defineNuxtModule } from '@nuxt/kit'
import { execa } from 'execa'
import { hash } from 'ohash'
import chalk from 'chalk'
import defu from 'defu'
import { createRouter as createRadixRouter, toRouteMatcher } from 'radix3'
import { withBase } from 'ufo'
import fg from 'fast-glob'
import { createBrowser, screenshot } from './runtime/browserService'
import type { OgImageRouteEntry, ScreenshotOptions } from './types'
import {
  HtmlRendererRoute,
  LinkPrerenderId,
  MetaOgImageContentPlaceholder,
  PayloadScriptId,
} from './runtime/const'

export interface ModuleOptions extends ScreenshotOptions {
  defaultIslandComponent: string
  /**
   * The directory within `public` where the og images will be stored.
   *
   * @default "_og-images"
   */
  outputDir: string
  /**
   * The hostname of your website.
   */
  host: string
  /**
   * Should images be allowed to generated at runtime.
   */
  runtimeImages: boolean
}

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: 'nuxt-og-image',
    compatibility: {
      nuxt: '^3.0.0',
      bridge: false,
    },
    configKey: 'ogImage',
  },
  defaults(nuxt) {
    return {
      host: nuxt.options.runtimeConfig.public?.siteUrl,
      width: 1200,
      height: 630,
      defaultIslandComponent: 'OgImage',
      outputDir: '_og-images',
      runtimeImages: nuxt.options.dev,
    }
  },
  async setup(config, nuxt) {
    const { resolve } = createResolver(import.meta.url)

    // @ts-expect-error need edge schema
    nuxt.options.experimental.componentIslands = true

    // paths.d.ts
    addTemplate({
      filename: 'nuxt-og-image.d.ts',
      getContents: () => {
        return `// Generated by nuxt-og-image
declare module 'nitropack' {
  interface NitroRouteRules {
    ogImage?: 'screenshot' | string | false
  }
}
`
      },
    })

    nuxt.hooks.hook('prepare:types', ({ references }) => {
      references.push({ path: resolve(nuxt.options.buildDir, 'nuxt-og-image.d.ts') })
    })

    // give a warning when accessing sitemap in dev mode
    addServerHandler({
      handler: resolve('./runtime/nitro/html'),
    })
    if (config.runtimeImages) {
      addServerHandler({
        handler: resolve('./runtime/nitro/image'),
      })
    }
    addImports({
      name: 'defineOgImage',
      from: resolve('./runtime/composables/defineOgImage'),
    })

    await addComponent({
      name: 'OgImage',
      filePath: resolve('./runtime/components/OgImage.vue'),
      // @ts-expect-error need to use @nuxt/kit edge
      island: true,
    })

    nuxt.hooks.hook('nitro:init', async (nitro) => {
      const entries: OgImageRouteEntry[] = []

      const _routeRulesMatcher = toRouteMatcher(
        createRadixRouter({ routes: nitro.options.routeRules }),
      )

      const outputPath = `${nitro.options.output.dir}/public/${config.outputDir}`
      // @ts-expect-error type missing
      nitro.hooks.hook('prerender:generate', async (ctx) => {
        // avoid scanning files and the og:image route itself
        if (ctx.route.includes('.') || ctx.route.endsWith(HtmlRendererRoute))
          return

        let html = ctx.contents
        // we need valid _contents to scan for ogImage payload and know the route is good
        if (!html)
          return

        const routeRules: NitroRouteRules = defu({}, ..._routeRulesMatcher.matchAll(ctx.route).reverse())
        if (routeRules.ogImage === false)
          return

        // check if the route path is not for a file
        const screenshotPath = ctx._contents.match(new RegExp(`<link id="${LinkPrerenderId}" rel="prerender" href="(.*?)">`))?.[1]
        const fileName = `${hash({ route: ctx.route, time: Date.now() })}.png`
        const absoluteUrl = withBase(`${config.outputDir}/${fileName}`, config.host)
        const entry: OgImageRouteEntry = {
          fileName,
          absoluteUrl,
          outputPath: `${nitro.options.output.dir}/public/${config.outputDir}/${fileName}`,
          linkingHtml: ctx.fileName,
          route: ctx.route,
          hasPayload: screenshotPath,
          routeRules: routeRules.ogImage || '',
          screenshotPath: screenshotPath || ctx.route,
        }
        // if payload exists, we're using a template and we need to render it now
        entries.push(entry)
        // fix placeholder meta
        html = html.replace(MetaOgImageContentPlaceholder, entry.absoluteUrl)
        ctx.contents = html
      })

      if (nuxt.options.dev)
        return

      const outputOgImages = async () => {
        if (entries.length === 0)
          return

        try {
          await mkdir(outputPath, { recursive: true })
        }
        catch (e) {}

        const previewProcess = execa('npx', ['serve', `${nitro.options.output.dir}/public`])
        try {
          previewProcess.stderr?.pipe(process.stderr)
          // wait until we get a message which says "Accepting connections"
          const host = (await new Promise<string>((resolve) => {
            previewProcess.stdout?.on('data', (data) => {
              if (data.includes('Accepting connections at')) {
                // get the url from data and return it as the promise
                resolve(data.toString().split('Accepting connections at ')[1])
              }
            })
          })).trim()
          const browser = await createBrowser()
          nitro.logger.info(`Generating ${entries.length} og:image screenshots`)
          try {
            for (const k in entries) {
              const entry = entries[k]
              const start = Date.now()
              const imgBuffer = await screenshot(browser, `${host}${entry.screenshotPath}`, config)
              await writeFile(entry.outputPath, imgBuffer)
              const generateTimeMS = Date.now() - start
              nitro.logger.log(chalk.gray(
                `  ${Number(k) === entries.length - 1 ? '└─' : '├─'} /${config.outputDir}/${entry.fileName} (${generateTimeMS}ms)`,
              ))
            }
          }
          catch (e) {
            console.error(e)
          }
          finally {
            await browser.close()
          }
        }
        catch (e) {
          console.error(e)
        }
        finally {
          previewProcess.kill()
        }
        // Clean up time
        // 1. post-process HTML, remove meta
        for (const entry of entries.filter(e => e.hasPayload)) {
          // read each html file and remove the payload data from the og generation
          const html = await readFile(`${nitro.options.output.dir}/public${entry.linkingHtml}`, 'utf-8')
          const newHtml = html
            .replace(new RegExp(`<link id="${LinkPrerenderId}" rel="prerender" href="(.*?)">`), '')
            // remove the script tag with the payload
            .replace(new RegExp(`<script id="${PayloadScriptId}" type="application/json">(.*?)</script>`), '')
            // remove any empty lines introduced
            .replace('\n\n', '\n')
          if (html !== newHtml) {
            // write the file back
            await writeFile(`${nitro.options.output.dir}/public${entry.linkingHtml}`, newHtml, { encoding: 'utf-8' })
          }
        }
        // 2. delete all of the _og-image folders
        const ogImageFolders = await fg([`**/${HtmlRendererRoute}`], { cwd: nitro.options.output.dir, onlyDirectories: true })
        for (const ogImageFolder of ogImageFolders)
          await rm(`${nitro.options.output.dir}/${ogImageFolder}`, { recursive: true, force: true })
      }

      // SSR mode
      nitro.hooks.hook('rollup:before', async () => {
        await outputOgImages()
      })

      // SSG mode
      nitro.hooks.hook('close', async () => {
        await outputOgImages()
      })
    })
  },
})
