import {defineNuxtModule, addTemplate, createResolver, addServerHandler} from '@nuxt/kit'
import {Nitro} from "nitropack";
import { writeFile, mkdir } from 'node:fs/promises'
import {execa} from "execa";
import { hash } from 'ohash'
import { ScreenshotOptions } from './types'
import {createBrowser, extractOgPayload, screenshot} from "./service";
import chalk from 'chalk'
import defu from "defu";
import { createRouter as createRadixRouter, toRouteMatcher } from 'radix3'
import {withQuery} from "ufo";

export interface ModuleOptions extends ScreenshotOptions {
  defaultIslandComponent: string
}

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: 'nuxt-og-image',
    compatibility: {
      nuxt: '^3.0.0',
      bridge: false,
    },
    configKey: 'ogImage',
  },
  defaults: {
    width: 1200,
    height: 630,
    defaultIslandComponent: 'OgImage',
  },
  async setup(config, nuxt) {
    const { resolve } = createResolver(import.meta.url)

    // paths.d.ts
    addTemplate({
      filename: 'nuxt-og-image.d.ts',
      getContents: () => {
        return `// Generated by nuxt-og-image
declare module 'nitropack' {
  interface NitroRouteRules {
    ogImage?: 'screenshot' | string | false
  }
}
`
      },
    })

    nuxt.hooks.hook('prepare:types', ({ references }) => {
      references.push({ path: resolve(nuxt.options.buildDir, 'nuxt-og-image.d.ts') })
    })

    // give a warning when accessing sitemap in dev mode
    addServerHandler({
      route: '/_api/og-image',
      handler: resolve('./runtime/handler'),
    })

    nuxt.hooks.hook('nitro:init', async (nitro: Nitro) => {
      let entries: { route: string, payload: Record<string, any> }[] = []

      nitro.hooks.hook('prerender:route', async (ctx) => {
        // check if the route path is not for a file
        // @ts-expect-error untyped
        if (!ctx.route.includes('.') && ctx._contents && !ctx._contents.includes('og:image')) {
          // from _contents which is html, we need to extract the title, description and meta
          const payload = extractOgPayload(ctx._contents)
          entries.push({ route: ctx.route, payload })
        }
      })

      if (nuxt.options.dev) {
        return
      }

      nitro.hooks.hook('close', async () => {
        if (entries.length === 0)
          return

        console.log(entries, nitro.options.output.dir)
        const _routeRulesMatcher = toRouteMatcher(
          createRadixRouter({ routes: nitro.options.routeRules }),
        )

        const previewProcess = execa(`nuxi`, ['preview', nitro.options.output.dir])
        try {
          previewProcess.stderr.pipe(process.stderr)
          // wait until we get a message which says "Accepting connections"
          const host = await new Promise<string>((resolve) => {
            previewProcess.stdout.on('data', (data) => {
              if (data.includes('Accepting connections at')) {
                // get the url from data and return it as the promise
                resolve(data.toString().split('Accepting connections at ')[1])
              }
            })
          })
          const browser = await createBrowser(config)
          nitro.logger.info(`Generating ${entries.length} og:image screenshots`)
          try {
            const outputDir = `${nitro.options.output.dir}/public/_og-images`
            // check if dir exists first
            try {
              await mkdir(outputDir, {recursive: true})
            } catch (e) {
              // fine if it already exists
            }
            const imageGenPromises = entries.map(async (entry, index) => {
              return new Promise<{ path: string; route: string } | false>(async (resolve) => {

                const routeRules = defu({}, ..._routeRulesMatcher.matchAll(entry.route).reverse())
                // @ts-expect-error untyped
                if (routeRules.ogImage === false) {
                  resolve(false)
                  return
                }

                const start = Date.now()
                // screenshot path
                let url = `${host}${entry}`
                // @ts-expect-error untyped
                if (routeRules.ogImage !== 'screenshot') {
                  // we're using a template
                  url = withQuery(`${host}/_api/og-image`, {
                    // @ts-expect-error untyped
                    template: routeRules.ogImage || config.defaultIslandComponent,
                    ...entry.payload
                  })
                  console.log('url', url)
                }
                const imgBuffer = await screenshot(browser, url, config)
                const fileName = hash({ route: entry, time: Date.now() })
                const path = `${outputDir}/${fileName}.png`
                await writeFile(path, imgBuffer)
                const generateTimeMS = Date.now() - start
                nitro.logger.log(chalk.gray(
                  `  ${index === entries.length - 1 ? '└─' : '├─'} /og-images/${fileName}.png (${generateTimeMS}ms)`,
                ))
                resolve({path, route: entry.route })
              })
            })
            // wait for all the promises in process to be finished
            const screenshots = await Promise.all(imageGenPromises)
          } catch (e) {
            console.error(e)
          } finally {
            await browser.close()
          }
        } catch (e) {
          console.error(e)
        } finally {
          previewProcess.kill()
        }
      })
    })
  },
})
