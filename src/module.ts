import { mkdir, readFile, rm, writeFile } from 'node:fs/promises'
import type { NitroRouteRules } from 'nitropack'
import { addComponent, addImports, addServerHandler, addTemplate, createResolver, defineNuxtModule, getNuxtVersion } from '@nuxt/kit'
import { execa } from 'execa'
import { hash } from 'ohash'
import chalk from 'chalk'
import defu from 'defu'
import { createRouter as createRadixRouter, toRouteMatcher } from 'radix3'
import { joinURL, withBase } from 'ufo'
import fg from 'fast-glob'
import { join } from 'pathe'
import type { Browser } from 'playwright-core'
import { createBrowser, screenshot } from './runtime/browserService'
import type { OgImageRouteEntry, ScreenshotOptions } from './types'
import {
  Constants,
  HtmlRendererRoute,
  LinkPrerenderId,
  MetaOgImageContentPlaceholder,
  PayloadScriptId,
} from './constants'

export interface ModuleOptions extends ScreenshotOptions {
  /**
   * The directory within `public` where the og images will be stored.
   *
   * @default "_og-images"
   */
  outputDir: string
  /**
   * The hostname of your website.
   */
  host: string
  /**
   * Should images be allowed to generated at runtime.
   */
  runtimeImages: boolean
}

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: 'nuxt-og-image',
    compatibility: {
      nuxt: '^3.0.0',
      bridge: false,
    },
    configKey: 'ogImage',
  },
  defaults(nuxt) {
    return {
      host: nuxt.options.runtimeConfig.public?.siteUrl,
      width: 1200,
      height: 630,
      defaultIslandComponent: 'OgImageTemplate',
      outputDir: '_og-images',
      runtimeImages: nuxt.options.dev,
    }
  },
  async setup(config, nuxt) {
    const { resolve } = createResolver(import.meta.url)

    // @ts-expect-error need edge schema
    nuxt.options.experimental.componentIslands = true

    // paths.d.ts
    addTemplate({
      filename: 'nuxt-og-image.d.ts',
      getContents: () => {
        return `// Generated by nuxt-og-image
declare module 'nitropack' {
  interface NitroRouteRules {
    ogImage?: 'screenshot' | string | false
  }
}
`
      },
    })

    nuxt.hooks.hook('prepare:types', ({ references }) => {
      references.push({ path: resolve(nuxt.options.buildDir, 'nuxt-og-image.d.ts') })
    })

    // we need edge version or 3.0.1 to use Nuxt Island
    if (getNuxtVersion(nuxt) !== '3.0.0') {
      // give a warning when accessing sitemap in dev mode
      addServerHandler({
        handler: resolve('./runtime/nitro/html'),
      })
      if (config.runtimeImages) {
        addServerHandler({
          handler: resolve('./runtime/nitro/image'),
        })
      }
    }
    addImports({
      name: 'defineOgImage',
      from: resolve('./runtime/composables/defineOgImage'),
    })
    addImports({
      name: 'defineOgImageScreenshot',
      from: resolve('./runtime/composables/defineOgImage'),
    })

    await addComponent({
      name: 'OgImageTemplate',
      filePath: resolve('./runtime/components/OgImageTemplate.island.vue'),
      // @ts-expect-error need to use @nuxt/kit edge
      island: true,
    })

    ;['OgImage', 'OgImageScreenshot'].forEach((name) => {
      addComponent({
        name,
        filePath: resolve(`./runtime/components/${name}`),
        // @ts-expect-error need to use @nuxt/kit edge
        island: true,
      })
    })

    const runtimeDir = resolve('./runtime')
    nuxt.options.build.transpile.push(runtimeDir)

    // add constants to app and nitro
    const constScript = Object.entries(Constants).map(([k, v]) => `export const ${k} = '${v}'`).join('\n')
    nuxt.options.alias['#nuxt-og-image/constants'] = addTemplate({
      filename: 'nuxt-og-image-constants.mjs',
      getContents: () => constScript,
    }).dst
    nuxt.hooks.hook('nitro:config', (nitroConfig) => {
      nitroConfig.externals = defu(nitroConfig.externals || {}, {
        inline: [runtimeDir],
      })
      nitroConfig.virtual!['#nuxt-og-image/constants'] = constScript
    })

    nuxt.hooks.hook('nitro:init', async (nitro) => {
      let entries: OgImageRouteEntry[] = []
      let cleanupEntries: OgImageRouteEntry[] = []

      const _routeRulesMatcher = toRouteMatcher(
        createRadixRouter({ routes: nitro.options.routeRules }),
      )

      const outputPath = join(nitro.options.output.publicDir, config.outputDir)
      // @ts-expect-error type missing
      nitro.hooks.hook('prerender:generate', async (ctx) => {
        // avoid scanning files and the og:image route itself
        if (ctx.route.includes('.') || ctx.route.endsWith(HtmlRendererRoute))
          return

        let html = ctx.contents
        // we need valid _contents to scan for ogImage payload and know the route is good
        if (!html)
          return

        if (!html.includes(`id="${PayloadScriptId}"`))
          return

        const routeRules: NitroRouteRules = defu({}, ..._routeRulesMatcher.matchAll(ctx.route).reverse())
        if (routeRules.ogImage === false)
          return

        // check if the route path is not for a file
        const screenshotPath = ctx._contents.match(new RegExp(`<link id="${LinkPrerenderId}" rel="prerender" href="(.*?)">`))?.[1]
        const fileName = `${hash({ route: ctx.route })}.png`
        const absoluteUrl = withBase(`${config.outputDir}/${fileName}`, config.host)
        const entry: OgImageRouteEntry = {
          fileName,
          absoluteUrl,
          outputPath: joinURL(nitro.options.output.publicDir, config.outputDir, fileName),
          linkingHtml: joinURL(nitro.options.output.publicDir, ctx.fileName),
          route: ctx.route,
          hasPayload: screenshotPath,
          routeRules: routeRules.ogImage || '',
          screenshotPath: screenshotPath || ctx.route,
        }
        // if payload exists, we're using a template and we need to render it now
        entries.push(entry)
        // fix placeholder meta
        html = html.replace(MetaOgImageContentPlaceholder, entry.absoluteUrl)
        ctx.contents = html
      })

      if (nuxt.options.dev)
        return

      const outputOgImages = async () => {
        if (entries.length === 0)
          return

        try {
          await mkdir(outputPath, { recursive: true })
        }
        catch (e) {}

        const previewProcess = execa('npx', ['serve', nitro.options.output.publicDir])
        let browser: Browser | null = null
        try {
          previewProcess.stderr?.pipe(process.stderr)
          // wait until we get a message which says "Accepting connections"
          const host = (await new Promise<string>((resolve) => {
            previewProcess.stdout?.on('data', (data) => {
              if (data.includes('Accepting connections at')) {
                // get the url from data and return it as the promise
                resolve(data.toString().split('Accepting connections at ')[1])
              }
            })
          })).trim()
          browser = await createBrowser()
          if (browser) {
            nitro.logger.info(`Generating ${entries.length} og:images...`)
            for (const k in entries) {
              const entry = entries[k]
              const start = Date.now()
              let hasError = false
              try {
                const imgBuffer = await screenshot(browser, `${host}${entry.screenshotPath}`, config)
                await writeFile(entry.outputPath, imgBuffer)
              }
              catch (e) {
                hasError = true
                console.error(e)
              }
              const generateTimeMS = Date.now() - start
              nitro.logger.log(chalk[hasError ? 'red' : 'gray'](
                `  ${Number(k) === entries.length - 1 ? '└─' : '├─'} /${config.outputDir}/${entry.fileName} (${generateTimeMS}ms) ${Math.round(Number(k) / (entries.length - 1) * 100)}%`,
              ))
            }
          }
        }
        catch (e) {
          console.error(e)
        }
        finally {
          await browser?.close()
          previewProcess.kill()
        }
        cleanupEntries = [...entries]
        entries = []
      }

      // SSR mode
      nitro.hooks.hook('rollup:before', async () => {
        await outputOgImages()
      })

      // SSG mode
      nitro.hooks.hook('close', async () => {
        await outputOgImages()

        // Clean up time
        // 1. post-process HTML, remove meta
        for (const entry of cleanupEntries) {
          // read each html file and remove the payload data from the og generation
          try {
            const html = await readFile(entry.linkingHtml, 'utf-8')
            const newHtml = html
              .replace(new RegExp(`<link id="${LinkPrerenderId}" rel="prerender" href="(.*?)">`), '')
            // remove the script tag with the payload
              .replace(new RegExp(`<script id="${PayloadScriptId}" type="application/json">(.*?)</script>`), '')
            // remove any empty lines introduced
              .replace('\n\n', '\n')
            if (html !== newHtml) {
            // write the file back
              await writeFile(entry.linkingHtml, newHtml, { encoding: 'utf-8' })
            }
          }
          // could fail from 404 links or something
          catch (e) {
            console.error(e)
          }
        }
        // 2. delete all of the _og-image folders
        const ogImageFolders = await fg([`**/${HtmlRendererRoute}`], { cwd: nitro.options.output.publicDir, onlyDirectories: true })
        for (const ogImageFolder of ogImageFolders)
          await rm(join(nitro.options.output.publicDir, ogImageFolder), { recursive: true, force: true })
      })
    })
  },
})
